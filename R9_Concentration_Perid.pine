//@version=6
indicator("횡보 구간 필터링 메타 지표 (MTF)", overlay=false, max_bars_back=500)

// ============================================
// 입력 파라미터
// ============================================
// 기본 설정
lookbackPeriod = input.int(20, "분석 기간", minval=5, maxval=100)
adxThreshold = input.int(25, "ADX 임계값", minval=10, maxval=50)
volatilityThreshold = input.float(3.0, "변동성 임계값 (%)", minval=0.5, maxval=10.0, step=0.5)
maConvergenceThreshold = input.float(2.0, "MA 수렴 임계값 (%)", minval=0.5, maxval=5.0, step=0.5)
slopeThreshold = input.float(0.1, "기울기 임계값 (%)", minval=0.01, maxval=1.0, step=0.01)

// 다중 타임프레임 설정
enableMTF = input.bool(true, "다중 타임프레임 활성화", group="MTF 설정")
higherTF1 = input.timeframe("60", "상위 타임프레임 1", group="MTF 설정")
higherTF2 = input.timeframe("240", "상위 타임프레임 2", group="MTF 설정")
higherTF3 = input.timeframe("D", "상위 타임프레임 3", group="MTF 설정")
mtfWeight1 = input.float(1.0, "TF1 가중치", minval=0.1, maxval=3.0, step=0.1, group="MTF 설정")
mtfWeight2 = input.float(1.5, "TF2 가중치", minval=0.1, maxval=3.0, step=0.1, group="MTF 설정")
mtfWeight3 = input.float(2.0, "TF3 가중치", minval=0.1, maxval=3.0, step=0.1, group="MTF 설정")

// 매물대 분석 설정
enableVolumeProfile = input.bool(true, "매물대 분석 활성화", group="매물대 설정")
vpLookback = input.int(100, "매물대 분석 기간", minval=50, maxval=500, group="매물대 설정")
vpLevels = input.int(20, "매물대 레벨 수", minval=10, maxval=50, group="매물대 설정")
vpThreshold = input.float(1.5, "주요 매물대 임계값", minval=1.0, maxval=3.0, step=0.1, group="매물대 설정")
enableMTFVolumeProfile = input.bool(true, "다중 타임프레임 매물대", group="매물대 설정")

// 돌파 감지 설정
enableBreakout = input.bool(true, "돌파 감지 활성화", group="돌파 설정")
breakoutLookback = input.int(20, "돌파 감지 기간", minval=10, maxval=100, group="돌파 설정")
breakoutThreshold = input.float(0.5, "돌파 임계값 (%)", minval=0.1, maxval=3.0, step=0.1, group="돌파 설정")
fakeBreakoutBars = input.int(5, "페이크 돌파 확인 바", minval=2, maxval=10, group="돌파 설정")
volumeMultiplier = input.float(1.5, "돌파 거래량 배수", minval=1.0, maxval=3.0, step=0.1, group="돌파 설정")
retestConfirmation = input.bool(true, "리테스트 확인", group="돌파 설정")

// 시그널 필터 설정
signalFrequencyLimit = input.int(5, "시그널 빈도 제한", minval=2, maxval=10, group="필터 설정")
confirmationBars = input.int(3, "확인 바 수", minval=1, maxval=10, group="필터 설정")
minConfidenceThreshold = input.float(0.3, "최소 신뢰도", minval=0.1, maxval=0.9, step=0.1, group="필터 설정")

// 시각화 설정
showSidewaysZone = input.bool(true, "횡보 구간 표시", group="표시 설정")
showConfidence = input.bool(true, "신뢰도 표시", group="표시 설정")
showMTFSignals = input.bool(true, "MTF 시그널 표시", group="표시 설정")
showIndividualSignals = input.bool(false, "개별 지표 시그널", group="표시 설정")
showBreakoutSignals = input.bool(true, "돌파 시그널 표시", group="표시 설정")
showVolumeProfile = input.bool(true, "매물대 표시", group="표시 설정")

// ============================================
// 매물대 계산 함수
// ============================================
calcVolumeProfile(highSrc, lowSrc, closeSrc, volumeSrc, lookback, levels) =>
    // 가격 범위 계산
    priceHigh = ta.highest(highSrc, lookback)
    priceLow = ta.lowest(lowSrc, lookback)
    priceRange = priceHigh - priceLow
    levelSize = priceRange / float(levels)
    
    // 각 레벨별 거래량 누적
    var array<float> volumeAtLevel = array.new_float(levels, 0.0)
    array.clear(volumeAtLevel)
    for i = 0 to levels - 1
        array.push(volumeAtLevel, 0.0)
    
    // 과거 데이터로 매물대 구축
    for i = 0 to lookback - 1
        barClose = closeSrc[i]
        barVolume = volumeSrc[i]
        if barClose >= priceLow and barClose <= priceHigh
            levelIndex = math.floor((barClose - priceLow) / levelSize)
            levelIndex := math.min(levelIndex, levels - 1)
            levelIndex := math.max(levelIndex, 0)
            currentVol = array.get(volumeAtLevel, int(levelIndex))
            array.set(volumeAtLevel, int(levelIndex), currentVol + barVolume)
    
    // 최대 거래량 찾기
    maxVolume = array.max(volumeAtLevel)
    
    // POC (Point of Control) 찾기
    pocIndex = 0
    pocVolume = 0.0
    for i = 0 to levels - 1
        levelVol = array.get(volumeAtLevel, i)
        if levelVol > pocVolume
            pocVolume := levelVol
            pocIndex := i
    
    pocPrice = priceLow + float(pocIndex) * levelSize + levelSize / 2.0
    
    // 주요 매물대 레벨 찾기 (임계값 이상)
    var array<float> significantLevels = array.new_float(0)
    array.clear(significantLevels)
    
    thresholdVolume = maxVolume * vpThreshold / 3.0
    for i = 0 to levels - 1
        levelVol = array.get(volumeAtLevel, i)
        if levelVol >= thresholdVolume
            levelPrice = priceLow + float(i) * levelSize + levelSize / 2.0
            array.push(significantLevels, levelPrice)
    
    // VAH (Value Area High) and VAL (Value Area Low) 계산
    totalVolume = array.sum(volumeAtLevel)
    valueAreaVolume = totalVolume * 0.7
    
    currentVolSum = array.get(volumeAtLevel, pocIndex)
    vahIndex = pocIndex
    valIndex = pocIndex
    
    upperIndex = pocIndex + 1
    lowerIndex = pocIndex - 1
    
    while currentVolSum < valueAreaVolume and (upperIndex < levels or lowerIndex >= 0)
        upperVol = upperIndex < levels ? array.get(volumeAtLevel, upperIndex) : 0.0
        lowerVol = lowerIndex >= 0 ? array.get(volumeAtLevel, lowerIndex) : 0.0
        
        if upperVol > lowerVol and upperIndex < levels
            currentVolSum := currentVolSum + upperVol
            vahIndex := upperIndex
            upperIndex := upperIndex + 1
        else if lowerIndex >= 0
            currentVolSum := currentVolSum + lowerVol
            valIndex := lowerIndex
            lowerIndex := lowerIndex - 1
        else if upperIndex < levels
            currentVolSum := currentVolSum + upperVol
            vahIndex := upperIndex
            upperIndex := upperIndex + 1
        else
            break
    
    vahPrice = priceLow + float(vahIndex) * levelSize + levelSize / 2.0
    valPrice = priceLow + float(valIndex) * levelSize + levelSize / 2.0
    
    [pocPrice, vahPrice, valPrice, significantLevels, maxVolume]

// ============================================
// 매물대 돌파 감지 함수
// ============================================
detectVolumeProfileBreakout(currentPrice, prevPrice, pocPrice, vahPrice, valPrice, significantLevels) =>
    breakoutType = 0
    breakoutStrength = 0.0
    levelBroken = 0.0
    
    // POC 돌파 체크 (가장 강력)
    pocBreakUp = currentPrice > pocPrice and prevPrice <= pocPrice
    pocBreakDown = currentPrice < pocPrice and prevPrice >= pocPrice
    
    if pocBreakUp
        breakoutType := 3
        breakoutStrength := 1.0
        levelBroken := pocPrice
    else if pocBreakDown
        breakoutType := -3
        breakoutStrength := 1.0
        levelBroken := pocPrice
    
    // VAH 돌파 체크
    vahBreakUp = currentPrice > vahPrice and prevPrice <= vahPrice
    vahBreakDown = currentPrice < vahPrice and prevPrice >= vahPrice
    
    if vahBreakUp and breakoutType == 0
        breakoutType := 2
        breakoutStrength := 0.8
        levelBroken := vahPrice
    else if vahBreakDown and breakoutType == 0
        breakoutType := -2
        breakoutStrength := 0.8
        levelBroken := vahPrice
    
    // VAL 돌파 체크
    valBreakUp = currentPrice > valPrice and prevPrice <= valPrice
    valBreakDown = currentPrice < valPrice and prevPrice >= valPrice
    
    if valBreakUp and breakoutType == 0
        breakoutType := 1
        breakoutStrength := 0.8
        levelBroken := valPrice
    else if valBreakDown and breakoutType == 0
        breakoutType := -1
        breakoutStrength := 0.8
        levelBroken := valPrice
    
    // 기타 주요 매물대 돌파 체크
    if breakoutType == 0 and array.size(significantLevels) > 0
        for i = 0 to array.size(significantLevels) - 1
            levelPrice = array.get(significantLevels, i)
            levelBreakUp = currentPrice > levelPrice and prevPrice <= levelPrice
            levelBreakDown = currentPrice < levelPrice and prevPrice >= levelPrice
            
            if levelBreakUp
                breakoutType := 1
                breakoutStrength := 0.6
                levelBroken := levelPrice
                break
            else if levelBreakDown
                breakoutType := -1
                breakoutStrength := 0.6
                levelBroken := levelPrice
                break
    
    [breakoutType, breakoutStrength, levelBroken]

// ============================================
// 다중 타임프레임 매물대 계산
// ============================================
calcMTFVolumeProfile() =>
    // 현재 타임프레임
    [poc, vah, val, levels, maxVol] = calcVolumeProfile(high, low, close, volume, vpLookback, vpLevels)
    
    // 1분봉
    [poc1m, vah1m, val1m, levels1m, maxVol1m] = request.security(syminfo.tickerid, "1", calcVolumeProfile(high, low, close, volume, vpLookback, vpLevels), lookahead=barmerge.lookahead_off)
    
    // 5분봉
    [poc5m, vah5m, val5m, levels5m, maxVol5m] = request.security(syminfo.tickerid, "5", calcVolumeProfile(high, low, close, volume, vpLookback, vpLevels), lookahead=barmerge.lookahead_off)
    
    // 15분봉
    [poc15m, vah15m, val15m, levels15m, maxVol15m] = request.security(syminfo.tickerid, "15", calcVolumeProfile(high, low, close, volume, vpLookback, vpLevels), lookahead=barmerge.lookahead_off)
    
    // 1시간봉
    [poc1h, vah1h, val1h, levels1h, maxVol1h] = request.security(syminfo.tickerid, "60", calcVolumeProfile(high, low, close, volume, vpLookback, vpLevels), lookahead=barmerge.lookahead_off)
    
    // 4시간봉
    [poc4h, vah4h, val4h, levels4h, maxVol4h] = request.security(syminfo.tickerid, "240", calcVolumeProfile(high, low, close, volume, vpLookback, vpLevels), lookahead=barmerge.lookahead_off)
    
    // 일봉
    [poc1d, vah1d, val1d, levels1d, maxVol1d] = request.security(syminfo.tickerid, "D", calcVolumeProfile(high, low, close, volume, vpLookback, vpLevels), lookahead=barmerge.lookahead_off)
    
    // 주봉
    [poc1w, vah1w, val1w, levels1w, maxVol1w] = request.security(syminfo.tickerid, "W", calcVolumeProfile(high, low, close, volume, vpLookback, vpLevels), lookahead=barmerge.lookahead_off)
    
    // 월봉
    [poc1M, vah1M, val1M, levels1M, maxVol1M] = request.security(syminfo.tickerid, "M", calcVolumeProfile(high, low, close, volume, vpLookback, vpLevels), lookahead=barmerge.lookahead_off)
    
    [poc, vah, val, levels, poc1m, poc5m, poc15m, poc1h, poc4h, poc1d, poc1w, poc1M, vah1m, vah5m, vah15m, vah1h, vah4h, vah1d, vah1w, vah1M, val1m, val5m, val15m, val1h, val4h, val1d, val1w, val1M, levels1m, levels5m, levels15m, levels1h, levels4h, levels1d, levels1w, levels1M]

// ============================================
// ADX 계산 함수
// ============================================
calcADX(highSrc, lowSrc, closeSrc, period) =>
    tr1 = highSrc - lowSrc
    tr2 = math.abs(highSrc - closeSrc[1])
    tr3 = math.abs(lowSrc - closeSrc[1])
    trValue = math.max(tr1, math.max(tr2, tr3))
    
    upMove = highSrc - highSrc[1]
    downMove = lowSrc[1] - lowSrc
    
    plusDM = upMove > downMove and upMove > 0 ? upMove : 0.0
    minusDM = downMove > upMove and downMove > 0 ? downMove : 0.0
    
    atrValue = ta.sma(trValue, period)
    plusDIValue = 100.0 * ta.sma(plusDM, period) / atrValue
    minusDIValue = 100.0 * ta.sma(minusDM, period) / atrValue
    
    dxValue = 100.0 * math.abs(plusDIValue - minusDIValue) / (plusDIValue + minusDIValue + 0.0001)
    adxResult = ta.sma(dxValue, period)
    adxResult

// ============================================
// 가격 변동성 계산 함수
// ============================================
calcVolatility(src, period) =>
    highestVal = ta.highest(src, period)
    lowestVal = ta.lowest(src, period)
    meanVal = ta.sma(src, period)
    volResult = 100.0 * (highestVal - lowestVal) / meanVal
    volResult

// ============================================
// 선형 회귀 기울기 계산 함수
// ============================================
calcSlope(src, period) =>
    sumX = 0.0
    sumY = 0.0
    sumXY = 0.0
    sumX2 = 0.0
    
    for i = 0 to period - 1
        xVal = float(i)
        yVal = src[period - 1 - i]
        sumX := sumX + xVal
        sumY := sumY + yVal
        sumXY := sumXY + xVal * yVal
        sumX2 := sumX2 + xVal * xVal
    
    nVal = float(period)
    denomVal = nVal * sumX2 - sumX * sumX
    slopeVal = denomVal != 0 ? (nVal * sumXY - sumX * sumY) / denomVal : 0.0
    normalizedSlopeVal = 100.0 * slopeVal / src
    normalizedSlopeVal

// ============================================
// MA 수렴도 계산 함수
// ============================================
calcMAConvergence(src) =>
    ma10Val = ta.sma(src, 10)
    ma20Val = ta.sma(src, 20)
    ma50Val = ta.sma(src, 50)
    
    maxMAVal = math.max(ma10Val, math.max(ma20Val, ma50Val))
    minMAVal = math.min(ma10Val, math.min(ma20Val, ma50Val))
    
    convResult = 100.0 * (maxMAVal - minMAVal) / src
    convResult

// ============================================
// 횡보 구간 감지 함수
// ============================================
detectSideways(highSrc, lowSrc, closeSrc, period, adxThresh, volThresh, slopeThresh, maConvThresh) =>
    adxCalc = calcADX(highSrc, lowSrc, closeSrc, period)
    volCalc = calcVolatility(closeSrc, period)
    slopeCalc = calcSlope(closeSrc, period)
    maConvCalc = calcMAConvergence(closeSrc)
    
    cond1 = adxCalc < adxThresh
    cond2 = volCalc < volThresh
    cond3 = math.abs(slopeCalc) < slopeThresh
    cond4 = maConvCalc < maConvThresh
    
    sidewaysResult = cond1 and cond2 and cond3 and cond4
    [sidewaysResult, adxCalc, volCalc, slopeCalc, maConvCalc]

// ============================================
// 돌파 감지 함수
// ============================================
detectBreakout(highSrc, lowSrc, closeSrc, volumeSrc, period, threshold) =>
    rangeHigh = ta.highest(highSrc, period)
    rangeLow = ta.lowest(lowSrc, period)
    rangeMid = (rangeHigh + rangeLow) / 2.0
    rangeSize = rangeHigh - rangeLow
    
    upperBreakLevel = rangeHigh * (1.0 + threshold / 100.0)
    lowerBreakLevel = rangeLow * (1.0 - threshold / 100.0)
    
    bullishBreakout = closeSrc > upperBreakLevel and closeSrc[1] <= rangeHigh
    bearishBreakout = closeSrc < lowerBreakLevel and closeSrc[1] >= rangeLow
    
    avgVolume = ta.sma(volumeSrc, period)
    volumeConfirm = volumeSrc > avgVolume * volumeMultiplier
    
    bullishStrength = bullishBreakout ? (closeSrc - rangeHigh) / rangeSize : 0.0
    bearishStrength = bearishBreakout ? (rangeLow - closeSrc) / rangeSize : 0.0
    
    breakoutType = bullishBreakout ? 1 : bearishBreakout ? -1 : 0
    breakoutStrength = bullishBreakout ? bullishStrength : bearishBreakout ? bearishStrength : 0.0
    
    [breakoutType, breakoutStrength, volumeConfirm, rangeHigh, rangeLow, rangeMid]

// ============================================
// 페이크 돌파 감지 함수
// ============================================
detectFakeBreakout(breakType, breakBar, currentBar, highSrc, lowSrc, closeSrc, rangeH, rangeL) =>
    isFake = false
    barsAfterBreak = currentBar - breakBar
    
    if barsAfterBreak > 0 and barsAfterBreak <= fakeBreakoutBars
        if breakType == 1
            lowestAfter = ta.lowest(lowSrc, barsAfterBreak)
            isFake := lowestAfter < rangeH
        else if breakType == -1
            highestAfter = ta.highest(highSrc, barsAfterBreak)
            isFake := highestAfter > rangeL
    
    isFake

// ============================================
// 리테스트 확인 함수
// ============================================
detectRetest(breakType, breakBar, currentBar, highSrc, lowSrc, closeSrc, rangeH, rangeL) =>
    hasRetest = false
    retestSuccess = false
    barsAfterBreak = currentBar - breakBar
    
    if barsAfterBreak > 0 and barsAfterBreak <= fakeBreakoutBars + 5
        if breakType == 1
            lowestAfter = ta.lowest(lowSrc, barsAfterBreak)
            hasRetest := lowestAfter <= rangeH * 1.01 and lowestAfter >= rangeH * 0.98
            if hasRetest
                retestSuccess := closeSrc > rangeH
        else if breakType == -1
            highestAfter = ta.highest(highSrc, barsAfterBreak)
            hasRetest := highestAfter >= rangeL * 0.99 and highestAfter <= rangeL * 1.02
            if hasRetest
                retestSuccess := closeSrc < rangeL
    
    [hasRetest, retestSuccess]

// ============================================
// 현재 타임프레임 횡보 감지
// ============================================
[isSideways, adx, volatility, slope, maConvergence] = detectSideways(high, low, close, lookbackPeriod, adxThreshold, volatilityThreshold, slopeThreshold, maConvergenceThreshold)

// ============================================
// 다중 타임프레임 횡보 감지
// ============================================
[isSidewaysTF1, adxTF1, volTF1, slopeTF1, maConvTF1] = request.security(syminfo.tickerid, higherTF1, detectSideways(high, low, close, lookbackPeriod, adxThreshold, volatilityThreshold, slopeThreshold, maConvergenceThreshold), lookahead=barmerge.lookahead_off)

[isSidewaysTF2, adxTF2, volTF2, slopeTF2, maConvTF2] = request.security(syminfo.tickerid, higherTF2, detectSideways(high, low, close, lookbackPeriod, adxThreshold, volatilityThreshold, slopeThreshold, maConvergenceThreshold), lookahead=barmerge.lookahead_off)

[isSidewaysTF3, adxTF3, volTF3, slopeTF3, maConvTF3] = request.security(syminfo.tickerid, higherTF3, detectSideways(high, low, close, lookbackPeriod, adxThreshold, volatilityThreshold, slopeThreshold, maConvergenceThreshold), lookahead=barmerge.lookahead_off)

// MTF 통합 횡보 점수 계산
currentWeight = 1.0
mtfTotalWeight = currentWeight + mtfWeight1 + mtfWeight2 + mtfWeight3

mtfSidewaysScore = 0.0
if enableMTF
    score1 = isSideways ? currentWeight : 0.0
    score2 = isSidewaysTF1 ? mtfWeight1 : 0.0
    score3 = isSidewaysTF2 ? mtfWeight2 : 0.0
    score4 = isSidewaysTF3 ? mtfWeight3 : 0.0
    mtfSidewaysScore := (score1 + score2 + score3 + score4) / mtfTotalWeight
else
    mtfSidewaysScore := isSideways ? 1.0 : 0.0

isSidewaysMTF = mtfSidewaysScore > 0.5

// ============================================
// 매물대 분석
// ============================================
var float pocCurrent = na
var float vahCurrent = na
var float valCurrent = na
var array<float> levelsCurrent = array.new_float(0)

var float poc1mCurrent = na
var float poc5mCurrent = na
var float poc15mCurrent = na
var float poc1hCurrent = na
var float poc4hCurrent = na
var float poc1dCurrent = na
var float poc1wCurrent = na
var float poc1MCurrent = na

if enableVolumeProfile and enableMTFVolumeProfile
    [poc, vah, val, levels, poc1m, poc5m, poc15m, poc1h, poc4h, poc1d, poc1w, poc1M, vah1m, vah5m, vah15m, vah1h, vah4h, vah1d, vah1w, vah1M, val1m, val5m, val15m, val1h, val4h, val1d, val1w, val1M, levels1m, levels5m, levels15m, levels1h, levels4h, levels1d, levels1w, levels1M] = calcMTFVolumeProfile()
    
    pocCurrent := poc
    vahCurrent := vah
    valCurrent := val
    levelsCurrent := levels
    
    poc1mCurrent := poc1m
    poc5mCurrent := poc5m
    poc15mCurrent := poc15m
    poc1hCurrent := poc1h
    poc4hCurrent := poc4h
    poc1dCurrent := poc1d
    poc1wCurrent := poc1w
    poc1MCurrent := poc1M
else if enableVolumeProfile
    [poc, vah, val, levels, maxVol] = calcVolumeProfile(high, low, close, volume, vpLookback, vpLevels)
    pocCurrent := poc
    vahCurrent := vah
    valCurrent := val
    levelsCurrent := levels

// ============================================
// 매물대 돌파 감지
// ============================================
var int vpBreakoutType = 0
var float vpBreakoutStrength = 0.0
var float vpLevelBroken = na
var int vpBreakoutBar = 0
var bool vpBreakoutActive = false

if enableVolumeProfile and not na(pocCurrent)
    [breakType, breakStrength, levelBroken] = detectVolumeProfileBreakout(close, close[1], pocCurrent, vahCurrent, valCurrent, levelsCurrent)
    
    if breakType != 0
        vpBreakoutType := breakType
        vpBreakoutStrength := breakStrength
        vpLevelBroken := levelBroken
        vpBreakoutBar := bar_index
        vpBreakoutActive := true

// 다중 타임프레임 매물대 돌파 점수
mtfVPBreakoutScore = 0.0
if enableVolumeProfile and enableMTFVolumeProfile
    vpScore = 0.0
    vpCount = 0
    
    // 각 타임프레임별 매물대 근처 여부 확인
    tolerance = close * 0.01
    
    if not na(poc1mCurrent) and math.abs(close - poc1mCurrent) < tolerance
        vpScore := vpScore + 1.0
        vpCount := vpCount + 1
    
    if not na(poc5mCurrent) and math.abs(close - poc5mCurrent) < tolerance
        vpScore := vpScore + 1.5
        vpCount := vpCount + 1
    
    if not na(poc15mCurrent) and math.abs(close - poc15mCurrent) < tolerance
        vpScore := vpScore + 2.0
        vpCount := vpCount + 1
    
    if not na(poc1hCurrent) and math.abs(close - poc1hCurrent) < tolerance
        vpScore := vpScore + 2.5
        vpCount := vpCount + 1
    
    if not na(poc4hCurrent) and math.abs(close - poc4hCurrent) < tolerance
        vpScore := vpScore + 3.0
        vpCount := vpCount + 1
    
    if not na(poc1dCurrent) and math.abs(close - poc1dCurrent) < tolerance
        vpScore := vpScore + 3.5
        vpCount := vpCount + 1
    
    if not na(poc1wCurrent) and math.abs(close - poc1wCurrent) < tolerance
        vpScore := vpScore + 4.0
        vpCount := vpCount + 1
    
    if not na(poc1MCurrent) and math.abs(close - poc1MCurrent) < tolerance
        vpScore := vpScore + 5.0
        vpCount := vpCount + 1
    
    mtfVPBreakoutScore := vpCount > 0 ? vpScore / float(vpCount) : 0.0

// ============================================
// 돌파 감지 및 검증
// ============================================
[breakoutType, breakoutStrength, volumeConfirm, rangeHigh, rangeLow, rangeMid] = detectBreakout(high, low, close, volume, breakoutLookback, breakoutThreshold)

// 돌파 발생 시 정보 저장
var int lastBreakoutType = 0
var int lastBreakoutBar = 0
var float lastRangeHigh = na
var float lastRangeLow = na
var bool breakoutActive = false

if breakoutType != 0 and enableBreakout and isSidewaysMTF[1]
    lastBreakoutType := breakoutType
    lastBreakoutBar := bar_index
    lastRangeHigh := rangeHigh
    lastRangeLow := rangeLow
    breakoutActive := true

// 페이크 돌파 감지
isFakeBreakout = false
if breakoutActive and not na(lastRangeHigh)
    isFakeBreakout := detectFakeBreakout(lastBreakoutType, lastBreakoutBar, bar_index, high, low, close, lastRangeHigh, lastRangeLow)
    if isFakeBreakout
        breakoutActive := false

// 리테스트 확인
[hasRetest, retestSuccess] = [false, false]
if breakoutActive and not na(lastRangeHigh) and retestConfirmation
    [hasRetest, retestSuccess] := detectRetest(lastBreakoutType, lastBreakoutBar, bar_index, high, low, close, lastRangeHigh, lastRangeLow)

// 돌파 신뢰도 계산
breakoutConfidence = 0.0
if breakoutActive and not isFakeBreakout
    breakoutConfidence := 0.4
    if volumeConfirm
        breakoutConfidence := breakoutConfidence + 0.2
    if breakoutStrength > 0.3
        breakoutConfidence := breakoutConfidence + 0.15
    if hasRetest and retestSuccess
        breakoutConfidence := breakoutConfidence + 0.15
    
    // 매물대 돌파 보너스
    if vpBreakoutActive and not na(vpLevelBroken)
        vpBonus = vpBreakoutStrength * 0.3
        breakoutConfidence := breakoutConfidence + vpBonus
    
    // MTF 매물대 중첩 보너스
    if mtfVPBreakoutScore > 2.0
        breakoutConfidence := breakoutConfidence + 0.2
    
    breakoutConfidence := math.min(breakoutConfidence, 1.0)

// 돌파 시그널
breakoutSignal = 0.0
if enableBreakout
    if breakoutActive and not isFakeBreakout
        breakoutSignal := lastBreakoutType * breakoutConfidence
    else if isFakeBreakout
        breakoutSignal := lastBreakoutType * -0.5

// ============================================
// RSI 시그널 생성 및 필터링
// ============================================
rsiPeriod = 14
rsiValue = ta.rsi(close, rsiPeriod)

rsiRawSignal = rsiValue < 30 ? 1.0 : rsiValue > 70 ? -1.0 : 0.0

recentRsiCount = 0
for i = 1 to 10
    if rsiRawSignal[i] != 0
        recentRsiCount := recentRsiCount + 1

tooFrequentRsi = recentRsiCount >= signalFrequencyLimit
rsiFilteredSignal = isSidewaysMTF and tooFrequentRsi ? 0.0 : rsiRawSignal

rsiTF1 = request.security(syminfo.tickerid, higherTF1, ta.rsi(close, rsiPeriod), lookahead=barmerge.lookahead_off)
rsiTF2 = request.security(syminfo.tickerid, higherTF2, ta.rsi(close, rsiPeriod), lookahead=barmerge.lookahead_off)
rsiTF3 = request.security(syminfo.tickerid, higherTF3, ta.rsi(close, rsiPeriod), lookahead=barmerge.lookahead_off)

rsiSignalTF1 = rsiTF1 < 30 ? 1.0 : rsiTF1 > 70 ? -1.0 : 0.0
rsiSignalTF2 = rsiTF2 < 30 ? 1.0 : rsiTF2 > 70 ? -1.0 : 0.0
rsiSignalTF3 = rsiTF3 < 30 ? 1.0 : rsiTF3 > 70 ? -1.0 : 0.0

rsiMTFSignal = 0.0
if enableMTF
    rsiWeightedSum = rsiFilteredSignal * currentWeight + rsiSignalTF1 * mtfWeight1 + rsiSignalTF2 * mtfWeight2 + rsiSignalTF3 * mtfWeight3
    rsiMTFSignal := rsiWeightedSum / mtfTotalWeight
else
    rsiMTFSignal := rsiFilteredSignal

// ============================================
// MA 크로스오버 시그널 생성 및 필터링
// ============================================
maFast = ta.sma(close, 10)
maSlow = ta.sma(close, 20)

goldenCross = ta.crossover(maFast, maSlow)
deathCross = ta.crossunder(maFast, maSlow)

maRawSignal = goldenCross ? 1.0 : deathCross ? -1.0 : 0.0

maFilteredTemp = isSidewaysMTF ? 0.0 : maRawSignal

var float maLastPrice = na
var int maLastType = 0
var int maLastBar = 0

if maFilteredTemp != 0
    maLastPrice := close
    maLastType := maFilteredTemp > 0 ? 1 : -1
    maLastBar := bar_index

maConfirmed = true
barsElapsed = bar_index - maLastBar

if not na(maLastPrice) and barsElapsed >= 0 and barsElapsed <= confirmationBars
    if maLastType == 1
        maxAfterCross = ta.highest(close, barsElapsed + 1)
        maConfirmed := maxAfterCross >= maLastPrice * 1.005
    else
        minAfterCross = ta.lowest(close, barsElapsed + 1)
        maConfirmed := minAfterCross <= maLastPrice * 0.995

maFilteredSignal = maFilteredTemp != 0 and not maConfirmed and barsElapsed <= confirmationBars ? 0.0 : maFilteredTemp

maFastTF1 = request.security(syminfo.tickerid, higherTF1, ta.sma(close, 10), lookahead=barmerge.lookahead_off)
maSlowTF1 = request.security(syminfo.tickerid, higherTF1, ta.sma(close, 20), lookahead=barmerge.lookahead_off)
maSignalTF1 = maFastTF1 > maSlowTF1 ? 1.0 : maFastTF1 < maSlowTF1 ? -1.0 : 0.0

maFastTF2 = request.security(syminfo.tickerid, higherTF2, ta.sma(close, 10), lookahead=barmerge.lookahead_off)
maSlowTF2 = request.security(syminfo.tickerid, higherTF2, ta.sma(close, 20), lookahead=barmerge.lookahead_off)
maSignalTF2 = maFastTF2 > maSlowTF2 ? 1.0 : maFastTF2 < maSlowTF2 ? -1.0 : 0.0

maFastTF3 = request.security(syminfo.tickerid, higherTF3, ta.sma(close, 10), lookahead=barmerge.lookahead_off)
maSlowTF3 = request.security(syminfo.tickerid, higherTF3, ta.sma(close, 20), lookahead=barmerge.lookahead_off)
maSignalTF3 = maFastTF3 > maSlowTF3 ? 1.0 : maFastTF3 < maSlowTF3 ? -1.0 : 0.0

maMTFSignal = 0.0
if enableMTF
    maWeightedSum = maFilteredSignal * currentWeight + maSignalTF1 * mtfWeight1 + maSignalTF2 * mtfWeight2 + maSignalTF3 * mtfWeight3
    maMTFSignal := maWeightedSum / mtfTotalWeight
else
    maMTFSignal := maFilteredSignal

// ============================================
// 볼린저 밴드 시그널 생성 및 보완
// ============================================
bbLength = 20
bbMult = 2.0

bbBasis = ta.sma(close, bbLength)
bbDev = bbMult * ta.stdev(close, bbLength)
bbUpper = bbBasis + bbDev
bbLower = bbBasis - bbDev

touchUpper = close >= bbUpper
touchLower = close <= bbLower

bbSignal = 0.0
if isSidewaysMTF
    bbSignal := touchUpper ? -1.0 : touchLower ? 1.0 : 0.0
else
    bbSignal := touchUpper ? 1.0 : touchLower ? -1.0 : 0.0

[bbBasisTF1, bbUpperTF1, bbLowerTF1] = request.security(syminfo.tickerid, higherTF1, [ta.sma(close, bbLength), bbUpper, bbLower], lookahead=barmerge.lookahead_off)
closeTF1 = request.security(syminfo.tickerid, higherTF1, close, lookahead=barmerge.lookahead_off)
touchUpperTF1 = closeTF1 >= bbUpperTF1
touchLowerTF1 = closeTF1 <= bbLowerTF1
bbSignalTF1 = isSidewaysTF1 ? (touchUpperTF1 ? -1.0 : touchLowerTF1 ? 1.0 : 0.0) : (touchUpperTF1 ? 1.0 : touchLowerTF1 ? -1.0 : 0.0)

[bbBasisTF2, bbUpperTF2, bbLowerTF2] = request.security(syminfo.tickerid, higherTF2, [ta.sma(close, bbLength), bbUpper, bbLower], lookahead=barmerge.lookahead_off)
closeTF2 = request.security(syminfo.tickerid, higherTF2, close, lookahead=barmerge.lookahead_off)
touchUpperTF2 = closeTF2 >= bbUpperTF2
touchLowerTF2 = closeTF2 <= bbLowerTF2
bbSignalTF2 = isSidewaysTF2 ? (touchUpperTF2 ? -1.0 : touchLowerTF2 ? 1.0 : 0.0) : (touchUpperTF2 ? 1.0 : touchLowerTF2 ? -1.0 : 0.0)

[bbBasisTF3, bbUpperTF3, bbLowerTF3] = request.security(syminfo.tickerid, higherTF3, [ta.sma(close, bbLength), bbUpper, bbLower], lookahead=barmerge.lookahead_off)
closeTF3 = request.security(syminfo.tickerid, higherTF3, close, lookahead=barmerge.lookahead_off)
touchUpperTF3 = closeTF3 >= bbUpperTF3
touchLowerTF3 = closeTF3 <= bbLowerTF3
bbSignalTF3 = isSidewaysTF3 ? (touchUpperTF3 ? -1.0 : touchLowerTF3 ? 1.0 : 0.0) : (touchUpperTF3 ? 1.0 : touchLowerTF3 ? -1.0 : 0.0)

bbMTFSignal = 0.0
if enableMTF
    bbWeightedSum = bbSignal * currentWeight + bbSignalTF1 * mtfWeight1 + bbSignalTF2 * mtfWeight2 + bbSignalTF3 * mtfWeight3
    bbMTFSignal := bbWeightedSum / mtfTotalWeight
else
    bbMTFSignal := bbSignal

// ============================================
// 신뢰도 계산 함수
// ============================================
calcConfidence(signal, historicalSignal) =>
    conf = 1.0
    
    if isSidewaysMTF
        conf := conf * 0.3
    
    if adx > 25
        conf := conf * (1.0 + (adx - 25.0) / 50.0)
    
    avgVol = ta.sma(volume, 20)
    volRatio = avgVol > 0 ? volume / avgVol : 1.0
    if volRatio > 1.0
        conf := conf * (1.0 + (volRatio - 1.0) * 0.5)
    else
        conf := conf * 0.7
    
    recentCount = 0
    for i = 1 to 10
        if historicalSignal[i] != 0
            recentCount := recentCount + 1
    
    if recentCount > 3
        conf := conf * 0.5
    
    if enableMTF
        alignCount = (isSideways ? 1 : 0) + (isSidewaysTF1 ? 1 : 0) + (isSidewaysTF2 ? 1 : 0) + (isSidewaysTF3 ? 1 : 0)
        alignBonus = alignCount == 4 or alignCount == 0 ? 1.3 : alignCount == 3 or alignCount == 1 ? 1.1 : 1.0
        conf := conf * alignBonus
    
    if breakoutActive and not isFakeBreakout
        conf := conf * 1.5
    
    if vpBreakoutActive and mtfVPBreakoutScore > 2.0
        conf := conf * 1.3
    
    finalConf = math.min(conf, 1.0)
    finalConf

rsiConfidence = calcConfidence(rsiMTFSignal, rsiRawSignal)
maConfidence = calcConfidence(maMTFSignal, maRawSignal)
bbConfidence = calcConfidence(bbMTFSignal, bbSignal)

// ============================================
// 통합 시그널
// ============================================
weightedSignalSum = rsiMTFSignal * rsiConfidence + maMTFSignal * maConfidence + bbMTFSignal * bbConfidence
confidenceSum = rsiConfidence + maConfidence + bbConfidence

consensusSignal = confidenceSum > 0 ? weightedSignalSum / confidenceSum : 0.0
consensusConfidence = confidenceSum > 0 ? confidenceSum / 3.0 : 0.0

// 돌파 시그널 통합
finalConsensusSignal = consensusSignal
if enableBreakout and breakoutActive and not isFakeBreakout
    if math.sign(breakoutSignal) == math.sign(consensusSignal)
        finalConsensusSignal := consensusSignal * 1.3
    else
        finalConsensusSignal := breakoutSignal * 0.7 + consensusSignal * 0.3

if isFakeBreakout
    finalConsensusSignal := breakoutSignal

// 최소 신뢰도 필터
finalSignal = consensusConfidence >= minConfidenceThreshold ? finalConsensusSignal : 0.0

// ============================================
// 시각화
// ============================================

// 횡보 구간 배경
bgcolor(showSidewaysZone and isSidewaysMTF ? color.new(color.yellow, 90) : na)

// 돌파 구간 배경
breakoutBgColor = breakoutActive and not isFakeBreakout ? (lastBreakoutType == 1 ? color.new(color.green, 85) : color.new(color.red, 85)) : na
bgcolor(showBreakoutSignals and breakoutBgColor != na ? breakoutBgColor : na)

// 페이크 돌파 배경
fakeBreakoutBg = isFakeBreakout ? color.new(color.orange, 80) : na
bgcolor(showBreakoutSignals and fakeBreakoutBg != na ? fakeBreakoutBg : na)

// 매물대 근처 배경
vpNearby = enableVolumeProfile and mtfVPBreakoutScore > 2.0 ? color.new(color.purple, 92) : na
bgcolor(showVolumeProfile and vpNearby != na ? vpNearby : na)

// 서브차트 기준선
hline(0, "중립", color=color.gray, linestyle=hline.style_dashed)
hline(0.5, "강한 매수", color=color.green, linestyle=hline.style_dotted)
hline(-0.5, "강한 매도", color=color.red, linestyle=hline.style_dotted)

// 통합 시그널 플롯
signalColor = finalSignal > 0 ? color.new(color.green, 0) : finalSignal < 0 ? color.new(color.red, 0) : color.new(color.blue, 0)
plot(finalSignal, "통합 시그널", color=signalColor, linewidth=3)
plot(showConfidence ? consensusConfidence : na, "신뢰도", color=color.new(color.orange, 0), linewidth=2)

// MTF 점수 플롯
plot(showMTFSignals ? mtfSidewaysScore - 1.5 : na, "MTF 횡보", color=color.new(color.purple, 0), linewidth=1)

// 돌파 시그널 플롯
plot(showBreakoutSignals and breakoutActive ? breakoutSignal : na, "돌파 시그널", color=color.new(color.blue, 30), linewidth=2, style=plot.style_circles)

// 매물대 점수 플롯
plot(showVolumeProfile and enableVolumeProfile ? mtfVPBreakoutScore / 5.0 - 0.5 : na, "매물대 점수", color=color.new(color.fuchsia, 0), linewidth=1)

// 돌파 신뢰도 플롯
plot(showBreakoutSignals and breakoutActive ? breakoutConfidence - 1.0 : na, "돌파 신뢰도", color=color.new(color.teal, 0), linewidth=1)

// 시그널 강도 배경
signalBgColor = finalSignal > 0.5 ? color.new(color.green, 90) : finalSignal < -0.5 ? color.new(color.red, 90) : na
bgcolor(signalBgColor)

// 개별 지표 플롯
if showIndividualSignals
    plot(rsiMTFSignal * 0.3, "RSI", color=color.new(color.purple, 50), linewidth=1)
    plot(maMTFSignal * 0.3, "MA", color=color.new(color.green, 50), linewidth=1)
    plot(bbMTFSignal * 0.3, "BB", color=color.new(color.red, 50), linewidth=1)

// ============================================
// 알림 조건
// ============================================
strongBuy = finalSignal > 0.5 and consensusConfidence > 0.5
strongSell = finalSignal < -0.5 and consensusConfidence > 0.5
signalCross = ta.cross(finalSignal, 0)
enterSideways = isSidewaysMTF and not isSidewaysMTF[1]
exitSideways = not isSidewaysMTF and isSidewaysMTF[1]

alertcondition(strongBuy, "강한 매수", "신뢰도 높은 매수 시그널")
alertcondition(strongSell, "강한 매도", "신뢰도 높은 매도 시그널")
alertcondition(signalCross, "시그널 전환", "매수/매도 전환")
alertcondition(enterSideways, "횡보 진입", "횡보 구간 진입")
alertcondition(exitSideways, "횡보 이탈", "추세 시작")

mtfFullAlign = (isSideways == isSidewaysTF1) and (isSideways == isSidewaysTF2) and (isSideways == isSidewaysTF3)
mtfAlignChange = mtfFullAlign and not mtfFullAlign[1]
alertcondition(mtfAlignChange, "MTF 완전 일치", "모든 타임프레임 일치")

bullishBreakoutAlert = breakoutType == 1 and volumeConfirm and enableBreakout and isSidewaysMTF[1]
bearishBreakoutAlert = breakoutType == -1 and volumeConfirm and enableBreakout and isSidewaysMTF[1]
fakeBreakoutAlert = isFakeBreakout and not isFakeBreakout[1]
retestSuccessAlert = hasRetest and retestSuccess and not (hasRetest[1] and retestSuccess[1])

alertcondition(bullishBreakoutAlert, "상향 돌파", "횡보 구간 상향 돌파 발생")
alertcondition(bearishBreakoutAlert, "하향 돌파", "횡보 구간 하향 돌파 발생")
alertcondition(fakeBreakoutAlert, "페이크 돌파 감지", "거짓 돌파 감지")
alertcondition(retestSuccessAlert, "리테스트 성공", "돌파 후 리테스트 성공")

// 매물대 돌파 알림
vpBreakoutAlert = vpBreakoutActive and not vpBreakoutActive[1] and vpBreakoutStrength > 0.7
vpMajorBreakout = mtfVPBreakoutScore > 3.0 and mtfVPBreakoutScore[1] <= 3.0

alertcondition(vpBreakoutAlert, "매물대 돌파", "주요 매물대 레벨 돌파")
alertcondition(vpMajorBreakout, "복합 매물대 돌파", "다중 타임프레임 매물대 중첩 돌파")